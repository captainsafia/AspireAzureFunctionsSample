# Aspire + Azure Functions Integration Sample

This project demonstrates the Aspire and Azure Functions integration.

> [!NOTE]  
> This repository requires a .NET 9 RC 2 SDK to support its functionality. It also requires 2.0.0-preview1 builds of the `Microsoft.Azure.Functions.Worker.Extensions.Http.AspNetCore` and `Microsoft.Azure.Functions.Worker.Sdk` packages.

## Running the project

This project requires the .NET 8.0.401 SDK and the Aspire workload.

```
dotnet workload install aspire
```

To run this project, launch the AppHost project.

```
cd AzureFunctionsTest/AzureFunctionsTest.AppHost
dotnet run
```

## Setting up the project

To replicate this setup on existing Azure Functions projects, a few modifications need to be made in order to work around current limitations in the integration.

1. Remove the default `AzureWebJobsStorage` configuration generated by the Azure Functions template in `local.settings.json`. The Aspire Azure Functions integration will configure the default host storage for Azure Functions using Aspire's Azure Storage integrations. These integrations handle launching the Azure Storage emulator and wiring up the endpoint references to the Azure Functions project, so no other explicit configuration is needed.

```diff
{
    "IsEncrypted": false,
    "Values": {
-        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "dotnet-isolated"
    }
}
```

2. Remove the default `--port` configured in the launch profile of the Azure Functions project. The Azure Functions Aspire integrations allocates a port that the Functions host will listen on. Currently, configuring two ports for the Functions host to listen on (one via the Aspire integration and one via the launch profile) is not feasible. To resolve this, remove the default port in the Functions project template and rely on Aspire to allocate it.

```diff
{
  "profiles": {
    "AzureFunctionsTest.Functions": {
      "commandName": "Project",
-      "commandLineArgs": "--port 7071",
      "launchBrowser": false
    }
  }
}
```

3. The Azure Functions host executes an inner build when `func start` is invoked that facilitates the discovery of triggers and extensions used by the worker and wiring them up to the host. Currently, a bug in the Azure Functions Core Tools makes this inner build fail in scenarios where the Functions project has already been built (see [this issue in the Azure Functions Core Tools repo](https://github.com/Azure/azure-functions-core-tools/issues/3594)).

```
Can't determine Project to build. Expected 1 .csproj or .fsproj but found 2
```

This bug especially impacts the Azure Functions integration because the referenced Functions project is built twice:

- Once during build phase when the AppHost is launched
- Again when `func start` command is called on the target project

To workaround this issue, configure Azure Functions so that the `WorkerExtensions.csproj` that is automatically generated during the first build is emitted to a sibling directory of the Functions project. Add the following to `AzureFunctionsTest.Functions`:

```
<PropertyGroup>
    <ExtensionsCsProjDirectory>$(MSBuildProjectDirectory)/../WorkerExtensions</ExtensionsCsProjDirectory>
</PropertyGroup>
```

4. Define explicit connection names on all Azure Functions bindings

Currently, there's a requirement that all Azure Functions trigger bindings specify a connection name that aligns with the name of the Aspire resource.

For example, given the following resource configuration for an Azure Storage Queue resource named "queue" and an Azure Storage Blobs resource named "blob":

```csharp
using Aspire.Hosting.Azure;

var builder = DistributedApplication.CreateBuilder(args);

var storage = builder.AddAzureStorage("storage").RunAsEmulator();
var queue = storage.AddQueues("queue");
var blob = storage.AddBlobs("blob");

 builder.AddAzureFunctionsProject<Projects.AzureFunctionsEndToEnd_Functions>("funcapp")
    .WithExternalHttpEndpoints()
    .WithReference(queue)
    .WithReference(blob)
```

The following trigger bindings must be used for Queue and Blob triggers respectively:

```csharp
[BlobTrigger("blobs/{name}", Connection = "blob")]
// ...
[QueueTrigger("queue", Connection = "queue")] 
```
 